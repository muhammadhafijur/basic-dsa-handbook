## Linked List ржХрзА?

Linked List рж╣рж▓рзЛ ржПржХржЯрж┐ рж▓рж┐ржирж┐рзЯрж╛рж░ ржбрзЗржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░, ржпрзЗржЦрж╛ржирзЗ ржЙржкрж╛ржжрж╛ржиржЧрзБрж▓рзЛ (nodes) ржорзЗржорзЛрж░рж┐рждрзЗ ржзрж╛рж░рж╛ржмрж╛рж╣рж┐ржХржнрж╛ржмрзЗ ржирж╛ ржерзЗржХрзЗ ржЫржбрж╝рж┐ржпрж╝рзЗ-ржЫрж┐ржЯрж┐ржпрж╝рзЗ ржерж╛ржХрзЗ, ржХрж┐ржирзНрждрзБ ржкрзНрж░рждрзНржпрзЗржХржЯрж┐ node ржкрж░ржмрж░рзНрждрзА node-ржПрж░ ржарж┐ржХрж╛ржирж╛ ржзрж░рзЗ рж░рж╛ржЦрзЗред рж╕рж╣ржЬ ржнрж╛рж╖рж╛рзЯ, рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯ рж╣рж▓рзЛ ржПржоржи ржПржХржЯрж┐ ржбрзЗржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржпрзЗржЦрж╛ржирзЗ ржкрзНрж░рждрж┐ржЯрж┐ ржПрж▓рж┐ржорзЗржирзНржЯ (ржпрж╛ржХрзЗ ржирзЛржб ржмрж▓рж╛ рж╣рзЯ) ржПржХржЯрж┐ ржбрзЗржЯрж╛ ржПржмржВ ржкрж░ржмрж░рзНрждрзА ржирзЛржбрзЗрж░ ржарж┐ржХрж╛ржирж╛ (ржкржпрж╝рзЗржирзНржЯрж╛рж░) рж░рж╛ржЦрзЗ ред ржкрзНрж░рждрж┐ржЯрж┐ node рж╕рж╛ржзрж╛рж░ржгржд ржжрзБржЗржЯрж┐ ржЕржВрж╢ ржирж┐ржпрж╝рзЗ ржЧржарж┐ржд:

Linked List ржП ржбрзЗржЯрж╛ рж╕ржВрж░ржХрзНрж╖ржгрзЗрж░ ржЬржирзНржп contiguous memory рж▓рж╛ржЧрзЗржирж╛, рждрж╛ржЗ ржПржЯрж╛ ржЕржирзЗржХ ржмрзЗрж╢рж┐ ржлрзНрж▓рзЗржХрзНрж╕рж┐ржмрж▓ред

1. **ржбрзЗржЯрж╛ (Data):** ржпрзЗ ржорж╛ржи рж╕ржВрж░ржХрзНрж╖ржг ржХрж░рж╛ рж╣рзЯ
2. **ржкржпрж╝рзЗржирзНржЯрж╛рж░ (Pointer/Next):** ржкрж░ржмрж░рзНрждрзА node ржПрж░ ржарж┐ржХрж╛ржирж╛

## ржХрзЗржи Linked List ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЛ?

ржЕрзНржпрж╛рж░рзЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж▓рзЗ ржлрж┐ржХрзНрж╕ржб рж╕рж╛ржЗржЬ рж░рж╛ржЦрждрзЗ рж╣рзЯ ржПржмржВ ржЗржирж╕рж╛рж░рзНржЯ ржмрж╛ ржбрж┐рж▓рж┐ржЯ ржЕржкрж╛рж░рзЗрж╢ржирзЗ ржЕржирзЗржХ рж╕ржорзЯ рж╢рж┐ржлржЯ ржХрж░рждрзЗ рж╣рзЯред ржХрж┐ржирзНрждрзБ Linked List-ржП:

- ржбрж╛ржЗржирж╛ржорж┐ржХ ржорзЗржорзЛрж░рж┐ ржмрзНржпржмрж╣рзГржд рж╣рзЯ (ржЪрж╛рж╣рж┐ржжрж╛ржорждрзЛ ржмрж╛рзЬрж╛ржирзЛ ржпрж╛рзЯ)
- ржЗржирж╕рж╛рж░рзНржЯ ржУ ржбрж┐рж▓рж┐ржЯ ржЕржирзЗржХ ржХрзНрж╖рзЗрждрзНрж░рзЗ ржжрзНрж░рзБржд рж╣рзЯ (ржмрж┐рж╢рзЗрж╖ ржХрж░рзЗ рж╢рзБрж░рзБрждрзЗ ржмрж╛ ржорж╛ржЭржЦрж╛ржирзЗ)

## Linked List ржжрзЗржЦрждрзЗ ржХрзЗржоржи?

ржзрж░рж┐ ржЖржорж╛ржжрзЗрж░ ржПржХржЯрж┐ рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯ ржЖржЫрзЗ:

```
[10 | *] тЖТ [20 | *] тЖТ [30 | *] тЖТ NULL
```

ржкрзНрж░рждрж┐ржЯрж┐ node ржПржХржЯрж┐ ржорж╛ржи (ржпрзЗржоржи 10, 20, 30) ржПржмржВ ржкрж░ржмрж░рзНрждрзА node ржПрж░ ржарж┐ржХрж╛ржирж╛ (\* ржЕржВрж╢) ржзрж░рзЗ рж░рж╛ржЦрзЗред

## Linked List ржПрж░ ржзрж░ржг

1. **Singly Linked List:** ржкрзНрж░рждрж┐ржЯрж┐ node рж╢рзБржзрзБ ржкрж░ржмрж░рзНрждрзА node ржПрж░ ржарж┐ржХрж╛ржирж╛ рж░рж╛ржЦрзЗред
2. **Doubly Linked List:** ржкрзНрж░рждрж┐ржЯрж┐ node ржЖржЧрзЗ ржУ ржкрж░рзЗ тАФ ржжрзБржЗ ржкрж╛рж╢рзЗрж░ node ржПрж░ ржарж┐ржХрж╛ржирж╛ рж░рж╛ржЦрзЗред
3. **Circular Linked List:** рж╢рзЗрж╖ node ржЖржмрж╛рж░ ржкрзНрж░ржержо node-ржХрзЗ ржирж┐рж░рзНржжрзЗрж╢ ржХрж░рзЗред

## Node рждрзИрж░рж┐ ржХрж░рж╛
Node рж╣рж▓рзЛ Linked List ржПрж░ рж╕ржмржЪрзЗрзЯрзЗ ржЫрзЛржЯ ржЗржЙржирж┐ржЯред
ржкрзНрж░рждрж┐ржЯрж┐ Node ржПрж░ ржоржзрзНржпрзЗ ржжрзБржЗржЯрж╛ ржЕржВрж╢ ржерж╛ржХрзЗ:

- Data (ржбрзЗржЯрж╛)

- Next Pointer (ржкрж░ржмрж░рзНрждрзА Node ржПрж░ ржарж┐ржХрж╛ржирж╛)

```cpp
#include<bits/stdc++.h>   // рж╕ржм рж╕рзНржЯрзНржпрж╛ржирзНржбрж╛рж░рзНржб рж▓рж╛ржЗржмрзНрж░рзЗрж░рж┐ ржПржХржмрж╛рж░рзЗ ржЗржиржХрзНрж▓рзБржб ржХрж░рж╛рж░ рж╣рзЗржбрж╛рж░
using namespace std;

class Node{
    public:
    int val;       // ржирзЛржбрзЗрж░ ржоржзрзНржпрзЗ рж░рж╛ржЦрж╛ ржбрзЗржЯрж╛ ( ржорж╛ржи )
    Node* next;    // ржкрж░ржмрж░рзНрждрзА ржирзЛржбрзЗрж░ ржарж┐ржХрж╛ржирж╛ (ржкржпрж╝рзЗржирзНржЯрж╛рж░)
};

int main()
{
    Node a,b,c;    // рждрж┐ржиржЯрж┐ ржирзЛржб ржЕржмржЬрзЗржХрзНржЯ рждрзИрж░рж┐ ржХрж░рж▓рж╛ржо
    a.val = 10;    
    b.val = 20;  
    c.val = 30;   

    a.next = &b;   // a ржирзЛржбрзЗрж░ ржкрж░ржмрж░рзНрждрзА ржирзЛржб рж╣рж▓рзЛ b ржПрж░ address
    b.next = &c;   // b ржирзЛржбрзЗрж░ ржкрж░ржмрж░рзНрждрзА ржирзЛржб рж╣рж▓рзЛ c ржПрж░ address
    c.next = NULL; // c ржирзЛржб рж▓рж┐рж╕рзНржЯрзЗрж░ рж╢рзЗрж╖, рждрж╛ржЗ ржкрж░ржмрж░рзНрждрзА ржирзЛржб ржирзЗржЗ, рждрж╛ржЗ NULL рж╕рзЗржЯ ржХрж░рзЗ ржжрж┐рж▓рж╛ржо

    cout << a.val << endl;   
    // cout << (*a.next).val << endl;  // a.next ржкржпрж╝рзЗржирзНржЯрж╛рж░ржХрзЗ ржбрж┐рж░рзЗржлрж╛рж░рзЗржирзНрж╕ ржХрж░рзЗ ржорж╛ржи ржирж┐ржмрзЗ (b ржПрж░ val) => рзирзж

    // cout << (*(*a.next).next).val << endl; // b.next (c) ржбрж┐рж░рзЗржлрж╛рж░рзЗржирзНрж╕ ржХрж░рзЗ рждрж╛рж░ ржорж╛ржи ржирзЗржмрзЗ => рзйрзж 
    // ржЙржкрж░рзЗрж░ ржПржЗ рж▓рж╛ржЗржиржЯрж╛ ржЖржорж┐ рж╢рзБржзрзБ ржкрзНрж░рж╛ржХржЯрж┐рж╕рзЗрж░ ржЬржирзНржп ржЯрзЗрж╕рзНржЯ ржХрж░рзЗ ржжрзЗржЦржЫрж┐рж▓рж╛ржо ред ржЖржорж░рж╛ рж╕рж╛ржзрж╛рж░ржгржд ржПржЗржнрж╛ржмрзЗ ржХрж░ржмрзЛ ржирж╛ ред

    cout << a.next->val << endl;  // ржПржЦрж╛ржирзЗ a.next ржкржпрж╝рзЗржирзНржЯрж╛рж░ ржжрж┐рзЯрзЗ b ржПрж░ ржорж╛ржи ржкрзНрж░рж┐ржирзНржЯ ржХрж░ржмрзЗ => рзирзж

    return 0;
}

```

## Constructor рж╕рж╣ Node
ржЖржорж░рж╛ Node рждрзИрж░рж┐рж░ рж╕ржорзЯ Data ржУ Next Pointer ржПржХрж╕рж╛ржерзЗ рж╕рзЗржЯ ржХрж░рж╛рж░ ржЬржирзНржп Constructor ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржкрж╛рж░рж┐ред

```cpp
#include<bits/stdc++.h>
using namespace std;

class Node {
public:
    int val;  
    Node* next;

    // Constructor : ржирждрзБржи ржирзЛржб рждрзИрж░рж┐ рж╣рж▓рзЗ ржПржЗ ржлрж╛ржВрж╢ржи ржЪрж╛рж▓рж╛ржирзЛ рж╣рзЯ
    Node(int val) {
        this->val = val;    // ржкрзНржпрж╛рж░рж╛ржорж┐ржЯрж╛рж░ рж╣рж┐рж╕рзЗржмрзЗ ржкрж╛ржУрзЯрж╛ val ржХрзЗ ржПржЗ ржирзЛржбрзЗрж░ val ржП рж╕рзЗржЯ ржХрж░рж▓рж╛ржо
        this->next = NULL;  // ржирждрзБржи ржирзЛржбрзЗрж░ ржкрж░ржмрж░рзНрждрзА ржирзЛржб ржПржЦржирзЛ ржирж╛ржЗ, рждрж╛ржЗ NULL ржжрж┐рзЯрзЗржЫрж┐
    }
};

int main()
{
    Node a(10), b(20), c(30);  
    // рзйржЯрж┐ ржирзЛржб рждрзИрж░рж┐ рж╣рж▓рзЛ, ржпрж╛рж░ ржорж╛ржи ржпржерж╛ржХрзНрж░ржорзЗ рззрзж, рзирзж, рзйрзж
    // ржПржЦрж╛ржирзЗ ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ, рждрж╛ржЗ ржнрзНржпрж╛рж▓рзБ рж╕рж░рж╛рж╕рж░рж┐ ржкрзНржпрж╛рж░рж╛ржорж┐ржЯрж╛рж░ рж╣рж┐рж╕рзЗржмрзЗ ржжрзЗрзЯрж╛ рж╣ржЪрзНржЫрзЗ

    a.next = &b;
    b.next = &c;

    cout << a.val << endl;
    cout << a.next->val << endl;

    return 0;
}

```

## Dynamic Node
Node ржЧрзБрж▓рзЛ рж╕рж╛ржзрж╛рж░ржгржд рж╣рж┐ржк ржорзЗржорзЛрж░рж┐ ржерзЗржХрзЗ ржбрж╛ржЗржирж╛ржорж┐ржХрзНржпрж╛рж▓рж┐ (runtime ржП) рждрзИрж░рж┐ ржХрж░рж╛ рж╣рзЯ new ржЕржкрж╛рж░рзЗржЯрж░ ржжрж┐рзЯрзЗред

```cpp
#include<bits/stdc++.h>
using namespace std;

class Node
{
public:
    int val;
    Node *next;
    Node(int val)
    {
        this->val = val;
        this->next = NULL;
    }
};

int main()
{
    Node* head = new Node(10);
    Node* a = new Node(20);
    Node* b = new Node(30);

    head->next = a;
    a->next = b;

    

    // a.next = &b;
    // ржЖржЧрзЗ a ржЫрж┐рж▓ ржПржХржЯрж╛ object ржХрж┐ржирзНрждрзБ ржПржЦржи head рж╣рж▓рзЛ ржПржХржЯрж╛ pointer

    cout << head->val << endl;         // head node ржПрж░ ржорж╛ржи ржкрзНрж░рж┐ржирзНржЯ ржХрж░ржмрзЗ (10)
    cout << head->next->val << endl;  // head ржПрж░ ржкрж░рзЗрж░ node ржПрж░ ржорж╛ржи ржкрзНрж░рж┐ржирзНржЯ ржХрж░ржмрзЗ (20)
    return 0;
}

```

**Thanks to Pias Vai for these insights.**

Notes from Pias vai :

- new ржХрзАржУржпрж╝рж╛рж░рзНржб ржПржХржЯрж┐ ржкржпрж╝рзЗржирзНржЯрж╛рж░ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗ
- рж╕рзЗржЗ ржкржпрж╝рзЗржирзНржЯрж╛рж░ржЯрж┐ ржЖржорж╛ржжрзЗрж░ рж░рж┐рж╕рж┐ржн ржХрж░рждрзЗ рж╣ржмрзЗ
- ржЖржорж╛ржжрзЗрж░ ржорзЗржорж░рж┐рждрзЗ ржжрзБржЗ ржзрж░ржирзЗрж░ ржорзЗржорж░рж┐ ржерж╛ржХрзЗ ржЖржорж░рж╛ ржЬрж╛ржирж┐
- ржПржХржЯрж╛ржГ heap memory, ржЖрж░рзЗржХржЯрж╛ржГ stack memory
- heap memory ржХрзЗ access ржХрж░рждрзЗ ржкрж╛рж░рзЗ new ржХрзАржУржпрж╝рж╛рж░рзНржб
- head ржкржпрж╝рзЗржирзНржЯрж╛рж░ рждрзИрж░рж┐ рж╣ржпрж╝ stack memory рждрзЗ
- node ржЧрзБрж▓рзЛ ржерж╛ржХрзЗ heap memory рждрзЗ
- ржПржЗ heap memory рждрзЗ ржпрзЗ node ржЧрзБрж▓рзЛ ржЖржЫрзЗ, рждрж╛ржжрзЗрж░ access ржХрж░рж╛рж░ ржЬржирзНржп ржкржпрж╝рзЗржирзНржЯрж╛рж░ ржжрж░ржХрж╛рж░
- рж╕рзЗржЗ ржкржпрж╝рзЗржирзНржЯрж╛рж░ ржерж╛ржХрзЗ stack memory рждрзЗ

## Linked List ржкрзНрж░рж┐ржирзНржЯ ржХрж░рж╛
```cpp
#include<bits/stdc++.h>
using namespace std;

class Node
{
public:
    int val;
    Node *next;
    Node(int val)
    {
        this->val = val;
        this->next = NULL;
    }
};

int main()
{
    Node* head = new Node(10);
    Node* a = new Node(20);
    Node* b = new Node(30);
    Node* c = new Node(40);

    head->next = a;
    a->next = b;
    b->next = c;


    Node* tmp = head;

    while(tmp != NULL){
        cout << tmp->val << endl;
        tmp = tmp->next;
    }

    return 0;
}
```
ржПржЦрж╛ржирзЗ ржЖржорж░рж╛ tmp ржирж╛ржорзЗрж░ ржПржХржЯрж╛ ржкржпрж╝рзЗржирзНржЯрж╛рж░ ржжрж┐ржпрж╝рзЗ рж▓рж┐рж╕рзНржЯрзЗрж░ рж╢рзБрж░рзБ ржерзЗржХрзЗ рж╢рзЗрж╖ ржкрж░рзНржпржирзНржд ржШрзБрж░рзЗ ржкрзНрж░рждрж┐ржЯрж┐ ржирзЛржбрзЗрж░ ржнрзНржпрж╛рж▓рзБ ржкрзНрж░рж┐ржирзНржЯ ржХрж░ржЫрж┐ред ржпрждржХрзНрж╖ржг tmp NULL ржирж╛ рж╣ржпрж╝ ( ржорж╛ржирзЗ рж▓рж┐рж╕рзНржЯрзЗрж░ рж╢рзЗрж╖ ржирж╛ рж╣ржУржпрж╝рж╛ ржкрж░рзНржпржирзНржд ) рждрждржХрзНрж╖ржг ржЖржорж░рж╛ рж▓рзБржк ржЪрж╛рж▓рж╛ржЪрзНржЫрж┐ред

#### ржПржЦржи ржкрзНрж░рж╢рзНржи рж╣ржЪрзНржЫрзЗ ржЖржорж░рж╛ ржХрзЗржи tmp ржкржпрж╝рзЗржирзНржЯрж╛рж░ ржирж┐рж▓рж╛ржо ? ржЖржорж░рж╛ ржХрзЗржи head ржжрж┐рзЯрзЗ ржХрж░рж▓рж╛ржо ржирж╛?

head рж╣ржЪрзНржЫрзЗ рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯрзЗрж░ рж╢рзБрж░рзБ ржПрж░ ржкржпрж╝рзЗржирзНржЯрж╛рж░ред ржпржжрж┐ рж╕рж░рж╛рж╕рж░рж┐ head ржжрж┐рзЯрзЗ рж▓рж┐рж╕рзНржЯ ржЯрзНрж░рж╛ржнрж╛рж░рзНрж╕ ржХрж░рж┐, рждрж╛рж╣рж▓рзЗ head ржПрж░ ржорж╛ржи ржкрж░рж┐ржмрж░рзНрждржи рж╣ржмрзЗред ржХрж┐ржирзНрждрзБ head ржЖржорж╛ржжрзЗрж░ рж▓рж┐рж╕рзНржЯрзЗрж░ ржкрзНрж░ржержо ржирзЛржбрзЗрж░ address, рж╕рзЗржЯрж╛ржХрзЗ ржЖржорж░рж╛ рж╣рж╛рж░рж╛рждрзЗ ржЪрж╛ржЗ ржирж╛ред
рждрж╛ржЗ, рж▓рж┐рж╕рзНржЯ ржШрзБрж░рж╛рж░ ржЬржирзНржп ржПржХржЯрж┐ ржирждрзБржи ржкржпрж╝рзЗржирзНржЯрж╛рж░ tmp ржирж┐рж▓рж╛ржо, ржпрзЗржЯрж╛ head ржПрж░ address ржкрж╛ржмрзЗред
ржПржЦржи tmp ржжрж┐рзЯрзЗ ржЖржорж░рж╛ рж▓рж┐рж╕рзНржЯ ржШрзБрж░ржмрзЛ, ржЖрж░ head ржЕржкрж░рж┐ржмрж░рзНрждрж┐ржд ржерж╛ржХржмрзЗред


## Reference of a Pointer

### **Pointer** ржХрзА?
Pointer рж╣рж▓рзЛ ржПржоржи ржПржХржЯрж┐ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ ржпрж╛ ржЕржирзНржп ржПржХржЯрж┐ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓рзЗрж░ **ржорзЗржорзЛрж░рж┐ ржЕрзНржпрж╛ржбрзНрж░рзЗрж╕** (ржарж┐ржХрж╛ржирж╛) рж╕ржВрж░ржХрзНрж╖ржг ржХрж░рзЗред рж╕рж╣ржЬ ржнрж╛рж╖рж╛рзЯ Pointer ржорзВрж▓ рждржерзНржп ржирж╛ рж░рзЗржЦрзЗ, рждржерзНржпржЯрж┐ ржХрзЛржерж╛ржпрж╝ ржЖржЫрзЗ рж╕рзЗржЯрж╛ ржмрж▓рзЗ ржжрзЗрзЯ ред

```cpp
int a = 10;
int* p = &a; 
```

> ржПржЦрж╛ржирзЗ `p` ржПржХржЯрж┐ pointer ржпрж╛ `a` ржПрж░ ржарж┐ржХрж╛ржирж╛ (address) ржзрж░рзЗ рж░рзЗржЦрзЗржЫрзЗред


### **Reference** ржХрзА?
Reference рж╣рж▓рзЛ ржПржХржЯрж┐ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓рзЗрж░ **ржЖрж░рзЗржХржЯрж┐ ржирж╛ржо** ржмрж╛ **ржЙржкржирж╛ржо**ред ржПржЯрж┐ ржирждрзБржи ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ ржирзЯ, ржмрж░ржВ ржЖржЧрзЗрж░ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓рзЗрж░ ржЙржкрж░рзЗржЗ ржХрж╛ржЬ ржХрж░рзЗред

```cpp
int a = 10;
int& ref = a;  // ref рж╣рж▓рзЛ a ржПрж░ ржЙржкржирж╛ржо
```

> ржПржЦржи `ref` ржжрж┐рзЯрзЗ `a` ржПрж░ ржорж╛ржи ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж╛ рж╕ржорзНржнржмред

ржЖрж░рзЗржХржЯрзБ ржнрж┐рждрж░рзЗ ржврзБржХрж╛ ржпрж╛ржХ,
ржПржЗржЦрж╛ржирзЗ `&` ржирж╛ ржмрзНржпрж╛ржмрж╣рж╛рж░ ржХрж░рж▓рзЗ ржХрж┐ рж╣ржмрзЗ?

ржПржЦрж╛ржирзЗ ```int& ref = a;``` ржорж╛ржирзЗ ref рж╣ржЪрзНржЫрзЗ a ржПрж░ reference, ржЕрж░рзНржерж╛рзО ref ржЖрж░рзЗржХржЯрж╛ ржирж╛ржо a ржПрж░ ржЬржирзНржпред

ржпржжрж┐ ржЖржорж┐ рж▓рж┐ржЦрж┐
```cpp
int a = 10;
int ref = a;  // ржПржЦрж╛ржирзЗ & ржирзЗржЗ
```

рждрж╛рж╣рж▓рзЗ ржПрж░ ржорж╛ржирзЗ рж╣ржмрзЗ:

- ref рж╣ржЪрзНржЫрзЗ ржирждрзБржи ржПржХржЯрж┐ int ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓,

- ржпрзЗржЯрж╛рж░ ржорж╛ржи рж╣ржмрзЗ a ржПрж░ ржорж╛ржирзЗрж░ copy тАФ ржЕрж░рзНржерж╛рзО рззрзж,

- ref ржЖрж░ a ржПржХрзЗ ржЕржкрж░рзЗрж░ ржерзЗржХрзЗ ржЖрж▓рж╛ржжрж╛ ржЖрж▓рж╛ржжрж╛ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓,

- ref ржПрж░ ржорж╛ржи ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж▓рзЗ a ржПрж░ ржорж╛ржи ржкрж░рж┐ржмрж░рзНрждржи рж╣ржмрзЗ ржирж╛ред

ржирж┐ржЪрзЗ ржПржХржЯрж╛ ржПржХрзНрж╕рж╛ржоржкрж▓ ржжрзЗржУрзЯрж╛ рж╣рж▓рзЛ :
```cpp
int a = 10;
int &ref = a;  // ref рж╣рж▓рзЛ a ржПрж░ reference (alias)

ref = 20;
cout << a << endl;  // 20 (ржХрж╛рж░ржг ref ржПржмржВ a ржПржХржЗ ржЬрж┐ржирж┐рж╕)

int b = 10;
int refNotRef = b;  // refNotRef рж╣рж▓рзЛ b ржПрж░ ржХржкрж┐

refNotRef = 20;
cout << b << endl;  // 10 (ржХрж╛рж░ржг refNotRef ржЖрж▓рж╛ржжрж╛ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓)

```

---
ржПржЦржи ржирж┐ржЪрзЗрж░ ржХрзЛржбржЯрж┐ рж░рж╛ржи ржХрж░рж┐ ред

```cpp
#include<bits/stdc++.h>
using namespace std;

void fun(int* p){
    cout << "Inside fun: " <<  *p << endl;
}

int main()
{
    int x = 2;
    int *p = &x;
    fun(p);
    cout << "Inside main: " <<  *p << endl;
    return 0;
}
```

```
Output:  
Inside fun: 2  
Inside main: 2
```

---

ржПржмрж╛рж░ fun function-ржП pointer ржЯрж┐ржХрзЗ dereference ржХрж░рзЗ ржПрж░ ржорж╛ржи 2 ржерзЗржХрзЗ 10 ржХрж░рзЗ ржжрж┐рж▓рж╛ржоред

```cpp
#include<bits/stdc++.h>
using namespace std;

void fun(int* p){
    *p = 10;
}

int main()
{
    int x = 2;
    int *p = &x;
    fun(p);
    cout << x << endl;
    return 0;
}
```
```
Output:  
10
```

ржПржЦрж╛ржирзЗ ржжрзЗржЦрзБржи `x` ржПрж░ ржорж╛ржи 2 ржирж╛ рж╣рзЯрзЗ 10 рж╣рзЯрзЗржЫрзЗред ржорж╛ржирзЗ рж╣ржЪрзНржЫрзЗ function ржПрж░ ржнрж┐рждрж░рзЗржУ ржпржжрж┐ pointer ржХрзЗ dereference ржХрж░рзЗ ржорж╛ржи ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж┐ рждрж╛рж╣рж▓рзЗ рж╕рзЗржЯрж╛ ржарж┐ржХржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗред

рждрж╛рж╣рж▓рзЗ рж╕ржорж╕рзНржпрж╛ ржХрзЛржерж╛рзЯ?

рж╕ржорж╕рзНржпрж╛ рж╣ржЪрзНржЫрзЗ ржЖржорж░рж╛ ржпржжрж┐ pointer-ржХрзЗ dereference ржирж╛ ржХрж░рзЗ ржмрж░ржВ pointer ржЯрж┐ржХрзЗржЗ ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рзЗ ржлрзЗрж▓рж┐ред ржмрж░рзНрждржорж╛ржирзЗ pointer `x` ржХрзЗ point ржХрж░ржЫрзЗред ржХрж┐ржирзНрждрзБ ржЖржорж░рж╛ function ржПрж░ ржнрж┐рждрж░рзЗ pointer ржХрзЗ ржЕржирзНржп ржХрж╛ржЙржХрзЗ point ржХрж░рждрзЗ ржмрж▓рж┐ред

```cpp
#include<bits/stdc++.h>
using namespace std;

void fun(int* p){
    int y = 20;
    p = &y;
}

int main()
{
    int x = 2;
    int *p = &x;
    fun(p);
    cout << *p << endl;
    return 0;
}
```

ржПржЦрж╛ржирзЗ ржЖржкржирж┐ ржпржжрж┐ ржХрзЛржбржЯрж┐ рж░рж╛ржи ржХрж░рзЗржи рждрж╛рж╣рж▓рзЗ ржжрзЗржЦржмрзЗржи Output ржЖрж╕ржмрзЗ 2ред 

ржЕрж░рзНржерж╛рзО,

**function ржПрж░ ржоржзрзНржпрзЗ ржпржжрж┐ pointer ржХрзЗ change ржХрж░рзЗ ржжрзЗржЗ рж╕рзЗржЗ ржкрж░рж┐ржмрж░рзНрждржиржЯрж╛ main function ржерзЗржХрзЗ ржЖрж░ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯ ржирж╛ред**

change ржорж╛ржирзЗ рж╣ржЪрзНржЫрзЗ pointer ржЯрж╛ ржпрзЗржЗ value ржХрзЗ point ржХрж░ржЫрж┐рж▓рзЛ, ржЖржорж░рж╛ рж╕рзЗржЯрж╛ change ржХрж░рзЗ ржЕржирзНржп ржПржХржЯрж┐ value ржХрзЗ point ржХрж░ржЫрж┐ ред

ржПржЦрж╛ржирзЗ Main function ржПрж░ `p` ржПржмржВ function ржПрж░ `p` ржПржХ ржирж╛ред  

рждрж╛рж╣рж▓рзЗ ржПрж░ ржкрзНрж░ржорж╛ржг ржХрзА?

ржЖржорж░рж╛ ржпржжрж┐ `fun` ржПрж░ ржнрж┐рждрж░рзЗ `p` ржПрж░ address ржПржмржВ main ржПрж░ ржнрж┐рждрж░рзЗ `p` ржПрж░ address ржкрзНрж░рж┐ржирзНржЯ ржХрж░рж┐ рждрж╛рж╣рж▓рзЗ ржжрзЗржЦржм рждрж╛рж░рж╛ ржЖрж▓рж╛ржжрж╛ред

```cpp
#include<bits/stdc++.h>
using namespace std;

void fun(int* p){
    int y = 20;
    p = &y;
    cout << "Inside fun: " <<  &p << endl;
}

int main()
{
    int x = 2;
    int *p = &x;
    fun(p);
    cout << "Inside main: " <<  &p << endl;
    return 0;
}
```

```
Output:  
Inside fun: 0x61fef0  
Inside main: 0x61ff08
```

  
> **Pointer ржХрзЗ dereference ржХрж░рж▓рзЗ, pointer-ржПрж░ ржоржзрзНржпрзЗ ржпрзЗржЗ address ржЯрж╛ ржЖржЫрзЗ, рж╕рзЗ ржР address ржП ржЧрж┐рзЯрзЗ ржпрзЗржЗ value ржЯрж╛ ржкрж╛рзЯ рж╕рзЗржЯрж╛ржЗ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рзЗ ржжрзЗрзЯ ред**



ржПржЦржи ржЖржорж░рж╛ ржпржжрж┐ ржЪрж╛ржЗ ржпрзЗ function ржПрж░ ржнрж┐рждрж░рзЗ pointer ржЯрж╛ржХрзЗ change ржХрж░рж▓рзЗ рж╕рзЗржЗ change ржЯрж╛ main function ржПржУ reflect ржХрж░рзБржХ тАФ рждрж╛рж╣рж▓рзЗ ржЖржорж╛ржжрзЗрж░ pointer-ржХрзЗ reference ржЖржХрж╛рж░рзЗ ржкрж╛ржарж╛рждрзЗ рж╣ржмрзЗред

ржПрж░ ржЬржирзНржп pointer ржкрж╛ржарж╛ржирзЛрж░ ржЖржЧрзЗ `&` (ampersand) ржЪрж┐рж╣рзНржи ржжрж┐рзЯрзЗ ржжрж┐рждрзЗ рж╣ржмрзЗ:

```cpp
#include<bits/stdc++.h>
using namespace std;

void fun(int* &p){
    int y = 20;
    p = &y;
    cout << "Inside fun: " <<  *p << endl;
}

int main()
{
    int x = 2;
    int *p = &x;
    fun(p);
    cout << "Inside main: " <<  *p << endl;
    return 0;
}
```
```
Output:  
Inside fun: 20  
Inside main: 20
```

---

ржПржмрж╛рж░ ржпржжрж┐ ржЖржорж░рж╛ ржирж┐ржЪрзЗрж░ ржХрзЛржбржЯрж┐ ржЪрж╛рж▓рж╛ржЗ, рждрж╛рж╣рж▓рзЗ ржжрзЗржЦржм ржпрзЗ, function ржУ mainтАФ ржЙржнрзЯ ржХрзНрж╖рзЗрждрзНрж░рзЗржЗ pointer ржПрж░ address ржПржХржЗред

```cpp
#include<bits/stdc++.h>
using namespace std;

void fun(int* p){
    int y = 20;
    p = &y;
    cout << "Inside fun: " <<  &p << endl;
}

int main()
{
    int x = 2;
    int *p = &x;
    fun(p);
    cout << "Inside main: " <<  &p << endl;
    return 0;
}
```



---

ЁЯУМ Note:  
Function ржПрж░ ржнрж┐рждрж░рзЗ ржпржжрж┐ ржЖржорж░рж╛ pointer ржЯрж╛ржХрзЗ change ржХрж░рж┐, ржПржмржВ рж╕рзЗржЗ change ржЯрж╛ main function ржПржУ ржЪрж╛ржЗ тАФ рждрж╛рж╣рж▓рзЗ pointer ржПрж░ ржЖржЧрзЗржЗ reference ржжрж┐рзЯрзЗ ржжрж┐рждрзЗ рж╣ржмрзЗред  

ржПржЗ concept ржЯрж┐ рж╕рж╛ржоржирзЗ ржЖржорж╛ржжрзЗрж░ **linked list** ржП ржХрж╛ржЬрзЗ рж▓рж╛ржЧржмрзЗред


##  Insert at Head - Singly Linked List Operation
ржЖржорж░рж╛ ржПржХржЯрж┐ Singly Linked List рждрзИрж░рж┐ ржХрж░ржмрзЛ ржПржмржВ рж╢рж┐ржЦржмрзЛ ржХрзАржнрж╛ржмрзЗ рж▓рж┐рж╕рзНржЯрзЗрж░ рж╣рзЗржбрзЗ (рж╕рж╛ржоржирзЗ) ржирждрзБржи ржирзЛржб ржпрзБржХрзНржд ржХрж░рж╛ ржпрж╛рзЯред

ржЖржкрж╛рждржд ржорзНржпрж╛ржирзБрзЯрж╛рж▓рж┐ ржирзЛржб рждрзИрж░рж┐ ржХрж░ржЫрж┐, ржкрж░рзЗ ржЖржорж░рж╛ рж╢рж┐ржЦржмрзЛ ржХрзАржнрж╛ржмрзЗ рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯрзЗ ржЗржЙржЬрж╛рж░ ржЗржиржкрзБржЯ ржерзЗржХрзЗ ржирзЛржб ржирзЗрзЯрж╛ ржпрж╛рзЯред

- ржПржЦржи рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯрзЗрж░ рж╣рзЗржбрзЗ ржПржХржЯрж┐ ржирждрзБржи ржирзЛржб ржЗржирж╕рж╛рж░рзНржЯ ржХрж░ржмрзЛред

- ржПржЗ ржХрж╛ржЬржЯрж┐ ржЖржорж░рж╛ ржПржХржЯрж┐ ржлрж╛ржВрж╢ржирзЗрж░ ржорж╛ржзрзНржпржорзЗ ржХрж░ржмрзЛред ржПрждрзЗ ржХрзЛржбржЯрж┐ organized ржерж╛ржХржмрзЗ ржПржмржВ ржмрзБржЭрждрзЗржУ рж╕рж╣ржЬ рж╣ржмрзЗред ржЖржмрж╛рж░ ржПржХржЗ ржХрж╛ржЬ ржмрж╛рж░ржмрж╛рж░ ржХрж░рждрзЗ ржЪрж╛ржЗрж▓рзЗ рж╢рзБржзрзБржорж╛рждрзНрж░ ржлрж╛ржВрж╢ржиржЯрж┐ ржХрж▓ ржХрж░рж▓рзЗржЗ ржЪрж▓ржмрзЗред

- ржПржЦржи ржерзЗржХрзЗ ржЖржорж░рж╛ ржПржЗ ржзрж░ржирзЗрж░ ржЕржкрж╛рж░рзЗрж╢ржиржЧрзБрж▓рзЛ ржлрж╛ржВрж╢ржирзЗрж░ ржорж╛ржзрзНржпржорзЗ ржХрж░рж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░ржмрзЛред

```cpp
#include<bits/stdc++.h>
using namespace std;

class Node
{
public:
    int val;
    Node *next;
    Node(int val)
    {
        this->val = val;
        this->next = NULL;
    }
};

void insert_at_head(Node* &head, int val){
    Node* newNode = new Node(val);
    newNode->next = head;
    head = newNode;
}

void print_linked_list(Node* head){
    Node* tmp = head;
    while(tmp != NULL){
        cout << tmp->val << endl;
        tmp = tmp->next;
    }
}

int main()
{
    // ржорзНржпрж╛ржирзБрзЯрж╛рж▓рж┐ ржХрж┐ржЫрзБ ржирзЛржб рждрзИрж░рж┐ ржХрж░ржЫрж┐
    Node* head = new Node(10);
    Node* a = new Node(20);
    Node* b = new Node(30);

    head->next = a;
    a->next = b;

    insert_at_head(head, 100);
    insert_at_head(head, 200);

    print_linked_list(head);
    
    return 0;
}

```



- рж▓ржХрзНрж╖рзНржп ржХрж░рж┐, ржкрзНрж░рж┐ржирзНржЯ ржХрж░рж╛рж░ ржлрж╛ржВрж╢ржирзЗ ржЖржорж░рж╛ рж╣рзЗржб ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж┐ржирж┐, рж╢рзБржзрзБ ржнрзНржпрж╛рж▓рзБржЧрзБрж▓рзЛ
      ржжрзЗржЦрж┐рзЯрзЗржЫрж┐ ред

- ржпржЦржи ржЖржорж░рж╛ ржЗржЙржЬрж╛рж░ ржЗржиржкрзБржЯ ржирж┐ржмрзЛ, рждржЦржи ржЖржорж░рж╛ рж╢рзЗрж╖ ржирзЛржбржЯрж┐ ржЖржЧрзЗ ржерзЗржХрзЗржЗ ржЬрж╛ржиржмрзЛ ржирж╛ ред

## Insert at Tail - Singly Linked List Operation
рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯрзЗрж░ ржПржХржжржо **рж╢рзЗрж╖рзЗ (tail ржП)** ржирждрзБржи ржПржХржЯрж┐ ржирзЛржб ржпрзБржХрзНржд ржХрж░рждрзЗ ржЪрж╛ржЗрж▓рзЗ ржЖржорж╛ржжрзЗрж░ ржкрзНрж░ржержорзЗ рж╢рзЗрж╖ ржирзЛржбржЯрж┐ ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рждрзЗ рж╣ржмрзЗ, рждрж╛рж░ржкрж░ рждрж╛рж░ `next` ржкрзЯрзЗржирзНржЯрж╛рж░ржЯрж┐ ржирждрзБржи ржирзЛржбрзЗрж░ ржжрж┐ржХрзЗ ржкржпрж╝рзЗржирзНржЯ ржХрж░рждрзЗ рж╣ржмрзЗред

```cpp
#include<bits/stdc++.h>
using namespace std;

class Node{
public:
    int val;
    Node* next;
    Node(int val){
        this->val = val;
        this->next = NULL;
    }
};


void insert_at_tail(Node* &head, int val){
    Node* newNode = new Node(val);

    // ржПржЗржЦрж╛ржирзЗ ржЖржорж░рж╛ ржЪрзЗржХ ржХрж░ржЫрж┐ ржпржжрж┐ рж▓рж┐рж╕рзНржЯ ржЦрж╛рж▓рж┐ ржерж╛ржХрзЗ рждрж╛рж╣рж▓рзЗ ржирждрзБржи ржирзЛржбржЯрж╛ржЗ рж╣рзЗржб
    if(head == NULL){
        head = newNode;
        return;
    }


    Node* tmp = head;
    while(tmp->next != NULL){
        tmp = tmp->next;
    }
    // now tmp in last node
    tmp->next = newNode;
}

void print_linked_list(Node* head){
    Node* tmp = head;
    while(tmp != NULL){
        cout << tmp->val << endl;
        tmp = tmp->next;
    }
}

int main(){

    Node* head = new Node(10);
    Node* a = new Node(20);
    Node* b = new Node(30);

    head->next = a;
    a->next = b;

    insert_at_tail(head, 40);

    print_linked_list(head);

    return 0;
}
```

```
Output: 
10
20
30
40
```

Note:
1. **Node ржХрзНрж▓рж╛рж╕** ржкрзНрж░рждрж┐ржЯрж┐ ржирзЛржбрзЗ ржерж╛ржХржмрзЗ ржПржХржЯрж┐ val ржПржмржВ ржПржХржЯрж┐ ржкрзЯрзЗржирзНржЯрж╛рж░ next ржпрзЗржЯрж╛ ржкрж░ржмрж░рзНрждрзА ржирзЛржбрзЗрж░ ржжрж┐ржХрзЗ ржЗржЩрзНржЧрж┐ржд ржХрж░рзЗред

2. **insert_at_tail() function:**

- ржкрзНрж░ржержорзЗ ржПржХржЯрж┐ ржирждрзБржи ржирзЛржб рждрзИрж░рж┐ ржХрж░рж╛ рж╣рзЯред

- ржпржжрж┐ head == NULL рж╣рзЯ, ржЕрж░рзНржерж╛рзО рж▓рж┐рж╕рзНржЯ ржЦрж╛рж▓рж┐ тАФ рждрж╛рж╣рж▓рзЗ ржирждрзБржи ржирзЛржбржЯрж╛ржЗ рж╣рзЗржб рж╣рзЯрзЗ ржпрж╛ржмрзЗред

- ржирж╛ рж╣рж▓рзЗ, ржЖржорж░рж╛ head ржерзЗржХрзЗ рж╢рзБрж░рзБ ржХрж░рзЗ next == NULL ржкрж░рзНржпржирзНржд ржЧрж┐рзЯрзЗржЫрж┐ (ржЕрж░рзНржерж╛рзО рж▓рж╛рж╕рзНржЯ ржирзЛржб ржкрж░рзНржпржирзНржд ржЧрж┐рзЯрзЗржЫрж┐)ред

- рждрж╛рж░ржкрж░ рж▓рж╛рж╕рзНржЯ ржирзЛржбрзЗрж░ next ржХрзЗ ржирждрзБржи ржирзЛржбрзЗрж░ ржжрж┐ржХрзЗ ржкрзЯрзЗржирзНржЯ ржХрж░рзЗржЫрж┐ред

3. **print_linked_list() function:** ржкрзНрж░рждрж┐ржЯрж┐ ржирзЛржб ржПржХрзЗ ржПржХрзЗ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рзЗред

---

**NOTE :**

ржЖржорж░рж╛ tmp ржирж╛ржорзЗрж░ ржПржХржЯрж┐ ржкржпрж╝рзЗржирзНржЯрж╛рж░ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗржЫрж┐ ржХрж╛рж░ржг,
- ржпржжрж┐ ржЖржорж░рж╛ рж╕рж░рж╛рж╕рж░рж┐ head ржжрж┐рзЯрзЗ рж▓рзБржк ржЪрж╛рж▓рж╛рждрж╛ржо, рждрж╛рж╣рж▓рзЗ head ржПрж░ ржорж╛ржи ржкрж░рж┐ржмрж░рзНрждржи рж╣рзЯрзЗ ржпрзЗржд, ржпрж╛ ржарж┐ржХ ржирж╛ред ржХрж╛рж░ржг head рж╣ржЪрзНржЫрзЗ ржЖржорж╛ржжрзЗрж░ ржкрзБрж░рзЛ рж▓рж┐рж╕рзНржЯрзЗрж░ reference ржмрж╛ starting pointред
- рждрж╛ржЗ ржЖржорж░рж╛ tmp ржирж╛ржорзЗ ржПржХржЯрж┐ ржирждрзБржи ржкржпрж╝рзЗржирзНржЯрж╛рж░ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж┐, ржпрзЗржЯрж╛ head ржХрзЗ ржХржкрж┐ ржХрж░рзЗ
```
Node* tmp = head;
```
- ржПрж░ржкрж░ tmp ржХрзЗ ржжрж┐рзЯрзЗ рж▓рж┐рж╕рзНржЯрзЗ ржШрзБрж░рж┐, ржпрждржХрзНрж╖ржг ржирж╛ ржкрж░рзНржпржирзНржд ржЖржорж░рж╛ рж╢рзЗрж╖ ржирзЛржбрзЗ ржкрзМржБржЫрж╛ржЗред

## Insert at any position - Singly Linked List Operation

ржЖржорж░рж╛ ржЖржЧрзЗ рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯрзЗрж░ **Head** ржПржмржВ **Tail** ржП ржЗржирж╕рж╛рж░рзНржЯ ржХрж░рж╛ рж╢рж┐ржЦрзЗржЫрж┐ред  
ржПржЦржи ржЖржорж░рж╛ рж╢рж┐ржЦржмрзЛ ржХрзАржнрж╛ржмрзЗ рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯрзЗрж░ **ржорж╛ржЭржЦрж╛ржирзЗрж░ ржпрзЗржХрзЛржирзЛ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржкржЬрж┐рж╢ржирзЗ** ржирждрзБржи ржПржХржЯрж┐ ржирзЛржб insert ржХрж░рж╛ ржпрж╛рзЯ ред

рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯрзЗ ржЖржорж░рж╛ ржпржжрж┐ ржорж╛ржЭржЦрж╛ржирзЗ ржХрзЛржирзЛ ржПржХржЯрж╛ ржкржЬрж┐рж╢ржирзЗ ржирждрзБржи ржирзЛржб ржпрзБржХрзНржд ржХрж░рждрзЗ ржЪрж╛ржЗ, рждрж╛рж╣рж▓рзЗ ржЖржорж╛ржжрзЗрж░ ржХрзЯрзЗржХржЯрж┐ ржзрж╛ржк ржЕржирзБрж╕рж░ржг ржХрж░рждрзЗ рж╣ржмрзЗ:

Steps:
- ржирждрзБржи Node рждрзИрж░рж┐ ржХрж░рж╛ ред
- ржирждрзБржи ржирзЛржбрзЗрж░ ржЖржЧрзЗ ржерж╛ржХрж╛ ржирзЛржб ржПрж░ ржкржЬрж┐рж╢ржирзЗ ржпрж╛ржУрзЯрж╛
- ржирждрзБржи Node-ржПрж░ next рж╕рзЗржЯ ржХрж░рзЛред
- ржЖржЧрзЗрж░ ржирзЛржбржЯрж┐рж░ next ржкрзЯрзЗржирзНржЯрж╛рж░ ржирждрзБржи Node-ржХрзЗ ржкрзЯрзЗржирзНржЯ ржХрж░рж╛

```cpp
#include<bits/stdc++.h>
using namespace std;

class Node
{
public:
    int val;
    Node *next;
    Node(int val)
    {
        this->val = val;
        this->next = NULL;
    }
};


void insert_at_any_pos(Node* head, int idx, int val){
    Node* newNode = new Node(val);
    // ржпржжрж┐ idx == 0 рж╣рзЯ, рждрж╛рж╣рж▓рзЗ ржирждрзБржи ржирзЛржб head рж╣ржмрзЗ
    if (idx == 0) {
        newNode->next = head;
        head = newNode;
        return;
    }

    Node* tmp = head;

    for(int i = 1; i < idx; i++){
        tmp = tmp->next;
        if(tmp == NULL) {
            return; // ржпржжрж┐ ржкржЬрж┐рж╢ржи ржнрзНржпрж╛рж▓рж┐ржб ржирж╛ рж╣рзЯ рждрж╛рж╣рж▓рзЗ return ржХрж░рзЗ ржжрж┐ржмрзЛ ред
        }
    }
    newNode->next = tmp->next;
    tmp->next = newNode;
}


void print_linked_list(Node* head){
    Node* tmp = head;
    while(tmp != NULL){
        cout << tmp->val << endl;
        tmp = tmp->next;
    }
}

int main()
{
    Node* head = new Node(10);
    Node* a = new Node(20);
    Node* b = new Node(30);
    Node* c = new Node(40);

    head->next = a;
    a->next = b;
    b->next = c;

    insert_at_any_pos(head, 2, 50);  


    print_linked_list(head);
    
    return 0;
}
```
--- 
```cpp
insert_at_any_pos(head, 2, 50);
```

ржПржЦрж╛ржирзЗ idx = 2 ржЕрж░рзНржерж╛рзО ржЖржорж░рж╛ index 2 рждрзЗ рзлрзж ржЗржирж╕рж╛рж░рзНржЯ ржХрж░рждрзЗ ржЪрж╛ржЗред
ржЖржорж░рж╛ ржпржжрж┐ index 0 ржерзЗржХрзЗ ржзрж░рж┐ рждрж╛рж╣рж▓рзЗ

ржпржжрж┐ ржЗржиржбрзЗржХрзНрж╕рж┐ржВ 0 ржерзЗржХрзЗ рж╢рзБрж░рзБ ржХрж░рж┐, рждрж╛рж╣рж▓рзЗ:

```cpp
index:   0     1     2     3
value:  10 -> 20 -> 30 -> 40
                тЖС
            ржПржЦрж╛ржирзЗ 50 ржмрж╕ржмрзЗ
```

```cpp
Index:     0            1            2            3

[ 10 | 2A ] -> [ 20 | 3D ] -> [ 30 | 4B ] -> [ 40 | NULL ] -> NULL

```

ржЖрж░рзЗржХржЯрзБ ржнрж╛рж▓рзЛ ржорждрзЛ ржбрж╛рзЯрж╛ржЧрзНрж░рж╛ржо ржЯрж╛ ржжрзЗржЦрждрзЗ ржЧрзЗрж▓рзЗ рж╕рзЗржЗржЯрж╛ рж╣ржмрзЗ ржЕржирзЗржХржЯрж╛ ржПржЗрж░ржХржо ред ржЖржорж░рж╛ ржмрзБржЭрж╛рж░ ржЬржирзНржп ржзрж░рзЗ ржирж┐рж▓рж╛ржо node ржПрж░ address ржЧрзБрж▓рзЛ ржПрж░ржХржо ред

```1A -> 2A -> 3D -> 4B```

```cpp
[ 10 | 2A ] ---> [ 20 | 3D ] ---> [ 30 | 4B ] ---> [ 40 | NULL ] ---> NULL
   1A              2A              3D               4B


```


ржЕржкрж╛рж░рзЗрж╢ржирзЗрж░ ржкрж░рзЗ рж▓рж┐рж╕рзНржЯ рж╣ржмрзЗ:
```cpp
10 -> 20 -> 50 -> 30 -> 40
```




ржЖржорж░рж╛ index 2 ржП ржирждрзБржи ржирзЛржб (рзлрзж) ржЗржирж╕рж╛рж░рзНржЯ ржХрж░ржмрзЛред


- ржЖржорж░рж╛ `new Node(val)` ржПрж░ ржорж╛ржзрзНржпржорзЗ ржирждрзБржи ржПржХржЯрж┐ ржирзЛржб рждрзИрж░рж┐ ржХрж░рж┐ред
- ржЖржорж░рж╛ `for` рж▓рзБржк ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ `tmp` ржХрзЗ `idx - рзз` рждржо ржирзЛржб ржкрж░рзНржпржирзНржд ржирж┐рзЯрзЗ ржпрж╛ржЗред ржПржЗ ржирзЛржбржЯрж┐ рж╣ржмрзЗ ржирждрзБржи ржирзЛржбрзЗрж░ ржЖржЧрзЗ ржерж╛ржХрж╛ ржирзЛржбред
- ржирждрзБржи ржирзЛржбрзЗрж░ `next` рж╣ржмрзЗ `tmp->next`, ржПрж░ржкрж░ `tmp->next` рж╣ржмрзЗ `newNode`ред

ржПржЦрж╛ржирзЗ ржХрзЗржи `Node* &head`?

ржПржЦрж╛ржирзЗ `&` ржорж╛ржирзЗ рж╣ржЪрзНржЫрзЗ reference to a pointer ред

ржПржЗ ржкржжрзНржзрждрж┐рждрзЗ ржлрж╛ржВрж╢ржирзЗрж░ ржнрж┐рждрж░рзЗ `head` ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж▓рзЗ, ржмрж╛ржЗрж░рзЗрж░ ржЖрж╕рж▓ `head` ржкрзЯрзЗржирзНржЯрж╛рж░ржУ ржЖржкржбрзЗржЯ рж╣рзЯред


## Insert at Tail ( Optimized ) тАФ Singly Linked List
ржЖржЧрзЗрж░ржмрж╛рж░ ржирждрзБржи ржирзЛржб ржпрзЛржЧ ржХрж░рж╛рж░ рж╕ржорзЯ рж▓рж┐рж╕рзНржЯрзЗрж░ рж╢рзБрж░рзБ ржерзЗржХрзЗ рж╢рзЗрж╖ ржкрж░рзНржпржирзНржд ржЧрж┐ржпрж╝рзЗ tail ржЦрзБржБржЬрждрзЗ рж╣рждрзЛ, ржлрж▓рзЗ Time Complexity рж╣рзЯ O(n)ред  

**Optimized Approach :**

**tail** ржирж╛ржорзЗ ржПржХржЯрж┐ ржкрзЯрзЗржирзНржЯрж╛рж░ рж░рзЗржЦрзЗ ржжрзЗржУрзЯрж╛ рж╣рзЯ, ржпрж╛ рж╕ржмрж╕ржорзЯ рж▓рж┐рж╕рзНржЯрзЗрж░ рж╢рзЗрж╖ ржирзЛржбрзЗрж░ address ржП ржерж╛ржХржмрзЗред рждрж╛ржЗ ржирждрзБржи ржирзЛржб ржпрзЛржЧ ржХрж░рждрзЗ рж╕рж░рж╛рж╕рж░рж┐ tail ржерзЗржХрзЗ ржХрж╛ржЬ рж╣ржмрзЗ, ржпрж╛рж░ Time Complexity рж╣ржмрзЗ O(1) ред

```cpp
#include<bits/stdc++.h>
using namespace std;

class Node{
    public:
    int val;
    Node* next;
    Node(int val){
        this->val = val;
        this->next = NULL;
    }
};

void insert_at_tail(Node* &head, Node* &tail, int val){
    Node* newNode = new Node(val);
    if(head == NULL){
        head = newNode;
        tail = newNode;
        return;
    }
    
    tail->next = newNode;
    tail = newNode;
}


void print_linked_list(Node* head){
    Node* tmp = head;
    while(tmp != NULL){
        cout << tmp->val << endl;
        tmp = tmp->next;
    }
}


int main(){
    Node* head = new Node(10);
    Node* a = new Node(20);
    Node* tail = new Node(30);

    head->next = a;
    a->next = tail;

    insert_at_tail(head, tail, 50);
    insert_at_tail(head, tail, 40);
    print_linked_list(head);

    return 0;
}

```
ржПржЦрж╛ржирзЗ,

- `insert_at_tail` ржлрж╛ржВрж╢ржирзЗ ржЖржорж░рж╛ head ржПржмржВ tail ржжрзБржЗржЯрж╛ржЗ рж░рзЗржлрж╛рж░рзЗржирзНрж╕ рж╣рж┐рж╕рзЗржмрзЗ ржжрж┐рзЯрзЗржЫрж┐ред
- ржирждрзБржи node рждрзИрж░рж┐ ржХрж░рж╛рж░ ржкрж░  tail node ржПрж░ ржкрж░рзЗ ржПржЯрж╛ржХрзЗ ржпрзБржХрзНржд ржХрж░рзЗржЫрж┐ ред
- ржПрж░ржкрж░ tail pointer ржЯрж╛ржХрзЗ ржЖржкржбрзЗржЯ ржХрж░рзЗржЫрж┐ ржпрзЗржи ржПржЯрж╛ рж╕ржмрж╕ржорзЯ рж▓рж┐рж╕рзНржЯрзЗрж░ рж╢рзЗрж╖ node ржХрзЗ point ржХрж░рзЗред

NOTE:
- ржпржжрж┐ рж▓рж┐рж╕рзНржЯ ржлрж╛ржБржХрж╛ ржерж╛ржХрзЗ (`head == NULL`), рждрж╛рж╣рж▓рзЗ ржирждрзБржи node ржЗ рж╣ржмрзЗ head ржПржмржВ tail тАФ ржХрж╛рж░ржг ржПржХржЯрж╛ node ржЗ рждржЦржи ржкрзБрж░рзЛ рж▓рж┐рж╕рзНржЯред
- ржПржмржВ ржПржЦржи ржкрзНрж░рждрж┐ржмрж╛рж░ ржирждрзБржи node ржпрзЛржЧ ржХрж░рждрзЗ рж╢рзБржзрзБ `tail->next = newNode` ржПржмржВ `tail = newNode` ржХрж░рж▓рзЗржЗ рж╢рзЗрж╖ тАФ ржЖрж░ рж▓рж┐рж╕рзНржЯ ржШрзБрж░рзЗ ржпрж╛ржУрзЯрж╛ рж▓рж╛ржЧрзЗ ржирж╛ред ржпрзЗрж╣рзЗрждрзБ function ржП ржПржЯрж┐ ржХрж░рзЗ рж░рзЗржЦрзЗржЫрж┐ рждрж╛ржЗ ржмрж╛рж░ ржмрж╛рж░ `insert_at_tail` function ржХрж▓ ржХрж░рж▓рзЗржЗ рж╣ржмрзЗ ред
- ржЖржорж░рж╛ ржпрзЗрж╣рзЗрждрзБ `tail` ржХрзЗ ржЯрзНрж░рзНржпрж╛ржХ ржХрж░рзЗ рж░рзЗржЦрзЗржЪрж┐, рждрж╛ржЗ ржирждрзБржи node insert ржХрж░рждрзЗ ржкрзБрж░рзЛ рж▓рж┐рж╕рзНржЯ traverse ржХрж░рж╛рж░ ржжрж░ржХрж╛рж░ ржирзЗржЗред ржлрж▓рзЗ ржЗржирж╕рж╛рж░рзНржЯ ржХрж░рж╛рж░ Time Complexity O(1), ржпрж╛ ржЕржирзЗржХ efficientред

## Taking input into a linked list
### Note:

- рж▓рж┐ржВржХржб рж▓рж┐рж╕рзНржЯрзЗ рж╕рж╛ржзрж╛рж░ржгржд **size** ржмрж▓рж╛ ржерж╛ржХрзЗ ржирж╛ред
- рждрж╛ржЗ ржмрзЗрж╢рж┐рж░ржнрж╛ржЧ Problem ржП ржЗржиржкрзБржЯрзЗрж░ рж╢рзЗрж╖рзЗ `-1` ржжрзЗржпрж╝рж╛ ржерж╛ржХрзЗ, ржпрж╛рж░ ржорж╛ржирзЗ рж╣ржЪрзНржЫрзЗ ржЗржиржкрзБржЯ ржПржЦрж╛ржирзЗржЗ рж╢рзЗрж╖ред
- ржПржЗ `-1` ржжрзЗржЦрзЗ ржЖржорж░рж╛ ржмрзБржЭрж┐, ржЖрж░ ржЗржиржкрзБржЯ ржирзЗржпрж╝рж╛ рж▓рж╛ржЧржмрзЗ ржирж╛ред
- ржЖржорж░рж╛ ржЗржиржкрзБржЯ ржирзЗржУржпрж╝рж╛рж░ рж╕ржоржпрж╝ ржкрзНрж░рждрж┐ржЯрж┐ ржнрзНржпрж╛рж▓рзБржХрзЗ рж▓рж┐ржВржХржб рж▓рж┐рж╕рзНржЯрзЗрж░ **рж╢рзЗрж╖рзЗ (tail)** ржпрзЛржЧ ржХрж░ржмрзЛ ред

### Steps:

1. ржкрзНрж░ржержорзЗ ржПржХржЯрж┐ `Node` ржХрзНрж▓рж╛рж╕ рждрзИрж░рж┐ ржХрж░ржм, ржпрзЗржЦрж╛ржирзЗ ржПржХржЯрж┐ ржнрзНржпрж╛рж▓рзБ ржПржмржВ ржПржХржЯрж┐ ржкрж░ржмрж░рзНрждрзА `Node` ржПрж░ ржЬржирзНржп ржкржпрж╝рзЗржирзНржЯрж╛рж░ ржерж╛ржХржмрзЗред
2. ржПрж░ржкрж░ ржПржХржЯрж┐ ржлрж╛ржВрж╢ржи рж▓рж┐ржЦржм, ржпрзЗржЯрж┐ **tail** ржП ржирждрзБржи ржирзЛржб ржпрзЛржЧ ржХрж░ржмрзЗред ржпржжрж┐ рж▓рж┐ржВржХржб рж▓рж┐рж╕рзНржЯ ржлрж╛ржБржХрж╛ рж╣ржпрж╝, рждрж╛рж╣рж▓рзЗ рж╕рзЗржЯрж╛ржЗ рж╣ржмрзЗ `head` ржУ `tail`ред
3. ржЗржЙржЬрж╛рж░ ржпрждржХрзНрж╖ржг ржкрж░рзНржпржирзНржд `-1` ржирж╛ ржжрзЗржпрж╝, рждрждржХрзНрж╖ржг ржЗржиржкрзБржЯ ржирж┐ржпрж╝рзЗ рж▓рж┐рж╕рзНржЯрзЗ ржпрзБржХрзНржд ржХрж░ржмред
4. рж╢рзЗрж╖рзЗ рж╕ржорзНржкрзВрж░рзНржг рж▓рж┐ржВржХржб рж▓рж┐рж╕рзНржЯржЯрж┐ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рзЗ ржжрзЗржЦрж╛ржмрзЛред


```cpp
#include <bits/stdc++.h>
using namespace std;


class Node {
public:
    int val;
    Node* next;

    Node(int val) {
        this->val = val;
        this->next = NULL;
    }
};


void insert_at_tail(Node* &head, Node* &tail, int val) {
    Node* newNode = new Node(val);
    
    if (head == NULL) {
        head = newNode;
        tail = newNode;
        return;
    }

    tail->next = newNode;
    tail = newNode;
}


void print_linked_list(Node* head) {
    Node* tmp = head;
    while (tmp != NULL) {
        cout << tmp->val << endl;
        tmp = tmp->next;
    }
}


int main() {
    Node* head = NULL;
    Node* tail = NULL;

    int val;
    while (true) {
        cin >> val;
        if (val == -1) break;
        insert_at_tail(head, tail, val);
    }

    print_linked_list(head);

    return 0;
}
```
ржЖржорж░рж╛ ржпрзЗрж╣рзЗрждрзБ tail ржП insert ржХрж░рж╛ ржЕржкржЯрж┐ржорж╛ржЗржЬржбржнрж╛ржмрзЗ рж╢рж┐ржЦрзЗржЫрж┐, рждрж╛ржЗ tail ржирж╛ржорзЗрж░ ржПржХржЯрж┐ ржкржпрж╝рзЗржирзНржЯрж╛рж░ржУ рж░рж╛ржЦржЫрж┐ред

`tail` track рж░рж╛ржЦрж▓рзЗ ржкрзНрж░рждрж┐ржмрж╛рж░ ржЗржирж╕рж╛рж░рзНржЯ ржХрж░рж╛рж░ рж╕ржоржпрж╝ ржкрзБрж░рзЛ рж▓рж┐рж╕рзНржЯ ржШрзБрж░рзЗ ржпрзЗрждрзЗ рж╣ржпрж╝ ржирж╛ред ржПржХрзЗржмрж╛рж░рзЗ рж╢рзЗрж╖рзЗ ржЧрж┐ржпрж╝рзЗ ржирждрзБржи ржирзЛржб add ржХрж░рж╛ ржпрж╛ржпрж╝ред

рждрж╛ржЗ insert_at_tail() ржПрж░ Time Complexity рж╣рзЯ O(1)ред

ржкрзБрж░рзЛ рж▓рж┐рж╕рзНржЯ ржЗржиржкрзБржЯ ржПржмржВ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рж╛рж░ ржЬржирзНржп ржЖржорж╛ржжрзЗрж░ Time Complexity рж╣рзЯ O(N)ред

ржХрж┐ржирзНрждрзБ ржпржжрж┐ ржЖржорж░рж╛ `tail` track ржирж╛ рж░рж╛ржЦрждрж╛ржо, рждрж╛рж╣рж▓рзЗ ржкрзНрж░рждрж┐ржмрж╛рж░ рж╢рзЗрж╖ ржирзЛржб ржЦрзБржБржЬрждрзЗ `O(N)` рж╕ржорзЯ рж▓рж╛ржЧржд, ржЖрж░ ржкрзБрж░рзЛ рж▓рж┐рж╕рзНржЯрзЗрж░ ржЬржирзНржп рж╕рзЗржЯрж╛ рж╣рзЯрзЗ ржпрзЗржд `O(N*N)` тАФ ржпрж╛ ржЕржирзЗржХ ржмрзЗрж╢рж┐ред


## Linked List Reverse Printing

### Note:
- рж▓рж┐ржВржХржб рж▓рж┐рж╕рзНржЯрзЗ **ржЗржиржбрзЗржХрзНрж╕** ржирзЗржЗ, рждрж╛ржЗ ржЖржорж░рж╛ рж╕рж░рж╛рж╕рж░рж┐ рж╢рзЗрж╖ ржерзЗржХрзЗ рж╢рзБрж░рзБ ржХрж░рзЗ ржХрж┐ржЫрзБ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рждрзЗ ржкрж╛рж░рж┐ ржирж╛ред
- ржПржХрзНрж╖рзЗрждрзНрж░рзЗ ржЦрзБржм ржнрж╛рж▓рзЛ ржПржХржЯрж┐ ржЯрзЗржХржирж┐ржХ рж╣рж▓рзЛ **recursion** ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ред
- рж░рж┐ржХрж╛рж░рж╢ржирзЗрж░ ржорж╛ржзрзНржпржорзЗ ржЖржорж░рж╛ рж▓рж┐рж╕рзНржЯрзЗрж░ ржПржХржжржо рж╢рзЗрж╖рзЗ ржЪрж▓рзЗ ржпрзЗрждрзЗ ржкрж╛рж░рж┐, рждрж╛рж░ржкрж░ ржкрзЗржЫржи ржерзЗржХрзЗ ржПржХрзЗ ржПржХрзЗ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рждрзЗ ржкрж╛рж░рж┐ред

---

### Steps:

1. ржПржХржЯрж┐ рж░рж┐ржХрж╛рж░рзНрж╕рж┐ржн ржлрж╛ржВрж╢ржи ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЛ, ржпрж╛ рж╢рзЗрж╖ ржкрж░рзНржпржирзНржд `NULL` ржкрж░рзНржпржирзНржд ржпрж╛ржмрзЗред
2. Recursion ржерзЗржХрзЗ ржлрзЗрж░рж╛рж░ ржкржерзЗ `Value` ржЧрзБрж▓рзЛ ржПржХрзЗ ржПржХрзЗ ржкрзНрж░рж┐ржирзНржЯ ржХрж░ржм тАФ ржПрждрзЗ ржХрж░рзЗ `Value` ржЧрзБрж▓рзЛ **ржкрзЗржЫржи ржерзЗржХрзЗ рж╕рж╛ржоржирзЗ** ржкрзНрж░рж┐ржирзНржЯ рж╣ржмрзЗред

---

### e.g. 

```cpp
#include <bits/stdc++.h>
using namespace std;


class Node {
public:
    int val;
    Node* next;

    Node(int val) {
        this->val = val;
        this->next = NULL;
    }
};


void insert_at_tail(Node* &head, Node* &tail, int val) {
    Node* newNode = new Node(val);

    if (head == NULL) {
        head = newNode;
        tail = newNode;
        return;
    }

    tail->next = newNode;
    tail = newNode;
}

// Reverse print with Recursion
void print_reverse(Node* tmp) {
    if (tmp == NULL) {
        return;
    }
    print_reverse(tmp->next); 
    cout << tmp->val << endl; 
}


int main() {
    Node* head = NULL;
    Node* tail = NULL;

    int val;
    while (true) {
        cin >> val;
        if (val == -1) break;
        insert_at_tail(head, tail, val);
    }

    print_reverse(head);

    return 0;
}
```
### More Info:

- рж░рж┐ржХрж╛рж░рж╢ржи ржЖрж╕рж▓рзЗ ржПржХржЯрж╛ рж╕рзНржЯрзНржпрж╛ржХрзЗрж░ ржорждрзЛ ржХрж╛ржЬ ржХрж░рзЗред

- ржЖржорж░рж╛ ржпржЦржи `print_reverse()` ржлрж╛ржВрж╢ржирзЗ ржПржХржЯрж╛ `Node` ржкрж╛ржарж╛ржЗ, рждржЦржи рж╕рзЗ ржЖржЧрзЗ рждрж╛рж░ ржкрж░рзЗрж░ `Node` ржПрж░ ржХрж╛ржЬ рж╢рзЗрж╖ ржХрж░рзЗ ржЖрж╕ржмрзЗред

- ржПржЗ ржЬржирзНржп ржЖржорж░рж╛ `cout << tmp->val` ржирж┐ржЪрзЗ рж░рж╛ржЦрж▓рзЗ рж╕рзЗржЯрж╛ рж░рж┐ржнрж╛рж░рзНрж╕ ржЕрж░рзНржбрж╛рж░рзЗ ржкрзНрж░рж┐ржирзНржЯ рж╣ржпрж╝ред

- ржПржЯрж┐ ржХрж░рж╛рж░ Time Complexity рж╣ржмрзЗ `O(N)` ред


## Delete at Head

### Note
- ржЖржорж░рж╛ ржпржжрж┐ **рж▓рж┐ржВржХржб рж▓рж┐рж╕рзНржЯрзЗрж░ ржкрзНрж░ржержо ржирзЛржб (head)** ржбрж┐рж▓рж┐ржЯ ржХрж░рждрзЗ ржЪрж╛ржЗ, рждрж╛рж╣рж▓рзЗ `head` ржХрзЗ ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рждрзЗ рж╣ржмрзЗред
- C++ ржП ржпрзЗрж╣рзЗрждрзБ ржкрзНржпрж╛рж░рж╛ржорж┐ржЯрж╛рж░ ржкрж╛рж╕ ржмрж╛ржЗ ржнрзНржпрж╛рж▓рзБ рж╣ржпрж╝, рждрж╛ржЗ `head` ржХрзЗ **reference** рж╣рж┐рж╕рзЗржмрзЗ ржкрж╛ржарж╛рждрзЗ рж╣ржмрзЗ, ржирж╛ рж╣рж▓рзЗ ржорзВрж▓ `head` ржкрж░рж┐ржмрж░рзНрждржи рж╣ржмрзЗ ржирж╛ред
- ржпрзЗрж╣рзЗрждрзБ ржЖржорж░рж╛ `new` ржжрж┐ржпрж╝рзЗ ржорзЗржорзЛрж░рж┐ рждрзИрж░рж┐ ржХрж░ржЫрж┐, рждрж╛ржЗ ржбрж┐рж▓рж┐ржЯ ржХрж░рж╛рж░ рж╕ржоржпрж╝ `delete` ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ рж╣ржмрзЗ ред


### Steps:

- ржкрзНрж░ржержорзЗ ржЖржорж░рж╛ ржЪрзЗржХ ржХрж░ржмрзЛ рж▓рж┐рж╕рзНржЯ ржЦрж╛рж▓рж┐ ржХрж┐ржирж╛ ред ржпржжрж┐ `head == NULL` рж╣ржпрж╝, рждрж╛рж╣рж▓рзЗ `return` ржХрж░рзЗ ржжрж┐ржмрзЛ ред
- ржПрж░ржкрж░ ржЖржорж░рж╛ ржПржХржЯрж┐ ржкржпрж╝рзЗржирзНржЯрж╛рж░ рж░рж╛ржЦржм ржпрж╛ ржмрж░рзНрждржорж╛ржи `head` ржХрзЗ ржкрзЯрзЗржирзНржЯ ржХрж░ржмрзЗ ред `Node* deleteNode = head;`
- `head` ржХрзЗ рждрж╛рж░ ржкрж░ржмрж░рзНрждрзА ржирзЛржбрзЗрж░ рж╕рж╛ржерзЗ ржХрж╛ржирзЗржХрзНржЯ ржХрж░ржмрзЛ  `head = head->next;`
- рж╕ржмрж╢рзЗрж╖рзЗ ржЖржорж░рж╛ ржЖржЧрзЗрж░ `head` (ржорж╛ржирзЗ `deleteNode`) ржХрзЗ ржорзЗржорзЛрж░рж┐ ржерзЗржХрзЗ ржбрж┐рж▓рж┐ржЯ ржХрж░рзЗ ржжрж┐ржм ред  `delete deleteNode;`


### e.g.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Node {
public:
    int val;
    Node* next;

    Node(int val) {
        this->val = val;
        this->next = NULL;
    }
};

void insert_at_tail(Node* &head, Node* &tail, int val) {
    Node* newNode = new Node(val);

    if (head == NULL) {
        head = newNode;
        tail = newNode;
        return;
    }

    tail->next = newNode;
    tail = newNode;
}

void print_linked_list(Node* head) {
    Node* tmp = head;
    while (tmp != NULL) {
        cout << tmp->val << endl;
        tmp = tmp->next;
    }
}

void delete_at_head(Node* &head) {
    if (head == NULL) return; 

    Node* deleteNode = head;   
    head = head->next;         
    delete deleteNode;       
}


int main() {
    Node* head = NULL;
    Node* tail = NULL;

    int val;
    while (true) {
        cin >> val;
        if (val == -1) break;
        insert_at_tail(head, tail, val);
    }

    delete_at_head(head);     
    print_linked_list(head); 

    return 0;
}
```

```cpp
Input:
10 20 30 40 -1

Output:
20
30
40

```


## Delete at Any Position

### Note :
- рж▓рж┐ржВржХржб рж▓рж┐рж╕рзНржЯрзЗ ржХрзЛржирзЛ ржЗржиржбрзЗржХрзНрж╕ ржерж╛ржХрзЗ ржирж╛, рждржмрзЗ ржЖржорж░рж╛ ржХрж╛рж▓рзНржкржирж┐ржХ ржЗржиржбрзЗржХрзНрж╕ ржзрж░рзЗ ржирж┐рждрзЗ ржкрж╛рж░рж┐ ред ржпрзЗржоржи:  

| Index | 0  | 1  | 2  | 3  |
|-------|----|----|----|----|
| Value | 10 | 20 | 30 | 40 |

- ржХрзЛржирзЛ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржкржЬрж┐рж╢ржи ржерзЗржХрзЗ ржбрж┐рж▓рж┐ржЯ ржХрж░рждрзЗ рж╣рж▓рзЗ, ржкрзНрж░ржержорзЗ ржУржЗ ржкржЬрж┐рж╢ржирзЗрж░ ржЖржЧрзЗрж░ ржирзЛржбржХрзЗ ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рждрзЗ рж╣ржмрзЗред
- рждрж╛рж░ржкрж░ ржУржЗ ржирзЛржбрзЗрж░ `next` ржкржпрж╝рзЗржирзНржЯрж╛рж░ ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рзЗ, ржбрж┐рж▓рж┐ржЯ ржХрж░рждрзЗ рж╣ржмрзЗ ржХрж╛ржЩрзНржХрзНрж╖рж┐ржд ржирзЛржбржХрзЗред

### Steps:

- ржкрзНрж░ржержорзЗ ржПржХржЯрж┐ ржкржпрж╝рзЗржирзНржЯрж╛рж░ ржжрж┐рзЯрзЗ рж▓рж┐рж╕рзНржЯрзЗрж░ `head` ржерзЗржХрзЗ рж╢рзБрж░рзБ ржХрж░рзЗ `idx-1` ржиржорзНржмрж░ ржкржЬрж┐рж╢ржирзЗрж░ ржирзЛржбрзЗ ржпрж╛ржмрзЛред
- рждрж╛рж░ржкрж░ ржР ржирзЛржбрзЗрж░ `next` (ржорж╛ржирзЗ `idx` ржкржЬрж┐рж╢ржирзЗрж░ ржирзЛржб) ржХрзЗ ржбрж┐рж▓рж┐ржЯ ржХрж░рж╛рж░ ржЬржирзНржп ржЖрж▓рж╛ржжрж╛ ржХрж░рзЗ рж░рж╛ржЦржмрзЛред
- ржР ржирзЛржбрзЗрж░ ржкрж░рзЗрж░ ржирзЛржбржХрзЗ `idx-1` ржкржЬрж┐рж╢ржирзЗрж░ ржирзЛржбрзЗрж░ `next` ржП рж╕рзЗржЯ ржХрж░рзЗ ржжрж┐ржмрзЛред
- рж╢рзЗрж╖рзЗ ржбрж┐рж▓рж┐ржЯ ржХрж░рж╛рж░ ржЬржирзНржп рж░рж╛ржЦрж╛ `deleteNode` ржбрж┐рж▓рж┐ржЯ ржХрж░рзЗ ржжрж┐ржмрзЛред


### e.g.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Node {
public:
  int val;
  Node* next;
  Node(int val) {
      this->val = val;
      this->next = NULL;
  }
};

void insert_at_tail(Node* &head, Node* &tail, int val) {
  Node* newNode = new Node(val);
  if (head == NULL) {
      head = newNode;
      tail = newNode;
      return;
  }
  tail->next = newNode;
  tail = newNode;
}

void print_linked_list(Node* head) {
  Node* tmp = head;
  while (tmp != NULL) {
      cout << tmp->val << endl;
      tmp = tmp->next;
  }
}

void delete_at_any_pos(Node* head, int idx) {
  Node* tmp = head;
  for (int i = 1; i < idx; i++) {
      tmp = tmp->next;
  }
  Node* deleteNode = tmp->next;
  tmp->next = tmp->next->next;
  delete deleteNode;
}

int main() {
  Node* head = NULL;
  Node* tail = NULL;

  int val;
  while (true) {
      cin >> val;
      if (val == -1) break;
      insert_at_tail(head, tail, val);
  }
  delete_at_any_pos(head, 2);
  print_linked_list(head);

  return 0;
}
```

```cpp
Input:
10 20 30 40 -1

Output:
10
20
40
```

## Delete at Tail

### Note:
- ржпрзЗрж╣рзЗрждрзБ ржЖржорж░рж╛ **singly linked list** ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржЫрж┐, рждрж╛ржЗ рж╕рж░рж╛рж╕рж░рж┐ `tail` ржерзЗржХрзЗ ржкрзЗржЫржирзЗ ржпрзЗрждрзЗ ржкрж╛рж░рж┐ ржирж╛ред
- рждрж╛ржЗ ржЯрзЗржЗрж▓ ржбрж┐рж▓рж┐ржЯ ржХрж░рждрзЗ рж╣рж▓рзЗ ржкрзНрж░ржержо ржерзЗржХрзЗ рж▓рж┐рж╕рзНржЯ ржЯрзНрж░рж╛ржнрж╛рж░рзНрж╕ ржХрж░рзЗ ржЯрзЗржЗрж▓рзЗрж░ ржЖржЧрзЗрж░ ржирзЛржб ржкрж░рзНржпржирзНржд ржпрзЗрждрзЗ рж╣ржмрзЗред
- ржПржЗ ржХрж╛рж░ржгрзЗ ржЯрзЗржЗрж▓ ржбрж┐рж▓рж┐ржЯрзЗрж░ Time Complexity рж╣рзЯ **O(N)**ред
- ржЖржЧрзЗрж░ `delete_at_any_pos` ржлрж╛ржВрж╢ржирзЗрж░ ржорждрзЛржЗ ржЯрзЗржЗрж▓ ржбрж┐рж▓рж┐ржЯ ржХрж░рж╛ ржпрж╛ржмрзЗ, рж╢рзБржзрзБ ржЯрзЗржЗрж▓ ржкрзЯрзЗржирзНржЯрж╛рж░ ржЖржкржбрзЗржЯ ржХрж░рждрзЗ рж╣ржмрзЗ ржЯрзЗржЗрж▓рзЗрж░ ржЖржЧрзЗрж░ ржирзЛржбрзЗред

---

### Steps:

- ржЖржорж░рж╛ рж╢рзБрж░рзБ ржерзЗржХрзЗ рж▓рж┐рж╕рзНржЯ ржЯрзНрж░рж╛ржнрж╛рж░рзНрж╕ ржХрж░рзЗ ржЯрзЗржЗрж▓рзЗрж░ ржЖржЧрзЗрж░ ржирзЛржбрзЗ ржпрж╛ржмрзЛред
- рж╕рзЗржЗ ржирзЛржбрзЗрж░ `next` ржкрзЯрзЗржирзНржЯрж╛рж░ `NULL` ржХрж░рзЗ ржжрж┐ржмрзЛ, ржХрж╛рж░ржг ржПржЯрж╛ ржПржЦржи ржирждрзБржи `tail` рж╣ржмрзЗред
- Old `tail` ржирзЛржбржХрзЗ ржбрж┐рж▓рж┐ржЯ ржХрж░ржм ржПржмржВ `tail` ржкрзЯрзЗржирзНржЯрж╛рж░ ржЖржкржбрзЗржЯ ржХрж░ржм ржирждрзБржи `tail` ржП ред


### e.g.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Node {
public:
    int val;
    Node* next;
    Node(int val) {
        this->val = val;
        this->next = NULL;
    }
};

void insert_at_tail(Node* &head, Node* &tail, int val) {
    Node* newNode = new Node(val);
    if (head == NULL) {
        head = newNode;
        tail = newNode;
        return;
    }
    tail->next = newNode;
    tail = newNode;
}

void print_linked_list(Node* head) {
    Node* tmp = head;
    while (tmp != NULL) {
        cout << tmp->val << endl;
        tmp = tmp->next;
    }
}

void delete_at_tail(Node* head, Node* &tail, int idx) {
    Node* tmp = head;
    for (int i = 1; i < idx; i++) {
        tmp = tmp->next;
    }
    Node* deleteNode = tmp->next;
    tmp->next = tmp->next->next;
    delete deleteNode;
    tail = tmp;
}

int main() {
    Node* head = NULL;
    Node* tail = NULL;

    int val;
    while (true) {
        cin >> val;
        if (val == -1) break;
        insert_at_tail(head, tail, val);
    }
    cout << "tail before delete -> " << tail->val << endl;
    delete_at_tail(head, tail, 3);
    cout << "tail after delete -> " << tail->val << endl;
    print_linked_list(head);

    return 0;
}
```

```cpp
Input:
10 20 30 40 -1

Output:
tail before delete -> 40
tail after delete -> 30
10
20
30
```


## Sorting a linked list with Selection Sort

### Note:
- ржПржЦрж╛ржирзЗ ржЖржорж░рж╛ **рж╢рзБржзрзБржорж╛рждрзНрж░ ржирзЛржбрзЗрж░ ржнрзНржпрж╛рж▓рзБ ржЧрзБрж▓рзЛ** ржЖржкржбрзЗржЯ ржмрж╛ рж╕рзЛржпрж╝рж╛ржк ржХрж░ржм, ржкрзБрж░рзЛ ржирзЛржбржЧрзБрж▓рзЛ рж╕рзНржерж╛ржирж╛ржирзНрждрж░ ржХрж░ржм ржирж╛ред
- рждрж╛ржЗ `head` ржкрж░рж┐ржмрж░рзНрждржирзЗрж░ ржжрж░ржХрж╛рж░ рж╣ржпрж╝ ржирж╛, ржПржЬржирзНржп ржЖржорж░рж╛ `head` ржХрзЗ рж░рзЗржлрж╛рж░рзЗржирзНрж╕ рж╣рж┐рж╕рзЗржмрзЗ ржкрж╛ржарж╛ржЗржирж┐ред
- ржПржЯрж┐ рж╣рж▓рзЛ **selection sort** ржПрж░ рж▓ржЬрж┐ржХ, ржпрж╛ ржжрзБржЗ рж▓рзБржк ржЪрж╛рж▓рж┐ржпрж╝рзЗ рж╕ржмржЪрзЗржпрж╝рзЗ ржЫрзЛржЯ (ржмрж╛ ржмржбрж╝) ржЙржкрж╛ржжрж╛ржи ржмрж╛ржЫрж╛ржЗ ржХрж░рзЗ ржарж┐ржХ ржЕржмрж╕рзНржерж╛ржирзЗ ржмрж╕рж╛ржпрж╝ред
- selection sort ржПрж░ Time Complexity рж╣рж▓рзЛ **O(N*N) ржмрж╛ **O(N┬▓)**ред

---

### Steps:

- ржмрж╛ржЗрж░рзЗрж░ рж▓рзБржк `i` ржжрж┐ржпрж╝рзЗ ржкрзНрж░ржержо ржерзЗржХрзЗ рж╢рзЗрж╖рзЗрж░ ржЖржЧрзЗрж░ ржирзЛржб ржкрж░рзНржпржирзНржд ржпрж╛ржмрзЛред
- ржнрж┐рждрж░рзЗрж░ рж▓рзБржк `j` ржжрж┐ржпрж╝рзЗ `i` ржПрж░ ржкрж░рзЗрж░ ржирзЛржб ржерзЗржХрзЗ рж╢рзЗрж╖ ржкрж░рзНржпржирзНржд ржпрж╛ржмрзЛред
- ржпржжрж┐ `i->val` ржмржбрж╝ рж╣ржпрж╝ `j->val` ржерзЗржХрзЗ, рждрж╛рж╣рж▓рзЗ рждрж╛ржжрзЗрж░ ржнрзНржпрж╛рж▓рзБ swap ржХрж░ржмрзЛред
- рж╢рзЗрж╖ ржкрж░рзНржпржирзНржд рж▓рж┐ржВржХржб рж▓рж┐рж╕рзНржЯ sort рж╣ржпрж╝рзЗ ржпрж╛ржмрзЗ (ascending order ржП)ред
- ржпржжрж┐ descending order ржХрж░рждрзЗ ржЪрж╛ржЗ, рждрж╛рж╣рж▓рзЗ `condition` ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж▓рзЗржЗ рж╣ржмрзЗ (`i->val < j->val`)ред

---

### e.g.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Node {
public:
    int val;
    Node* next;
    Node(int val) {
        this->val = val;
        this->next = NULL;
    }
};

void insert_at_tail(Node* &head, Node* &tail, int val) {
    Node* newNode = new Node(val);
    if (head == NULL) {
        head = newNode;
        tail = newNode;
        return;
    }
    tail->next = newNode;
    tail = newNode;
}

void print_linked_list(Node* head) {
    Node* tmp = head;
    while (tmp != NULL) {
        cout << tmp->val << endl;
        tmp = tmp->next;
    }
}

void sort_linked_list(Node* head) {
    for (Node* i = head; i->next != NULL; i = i->next) {
        for (Node* j = i->next; j != NULL; j = j->next) {
            if (i->val > j->val) {
                swap(i->val, j->val);
            }
        }
    }
}

/*
ржпржжрж┐ ржЖржорж░рж╛ i != NULL ржжрж┐рждрж╛ржо, рждрж╛рж╣рж▓рзЗ i рж╢рзЗрж╖ ржирзЛржб ржкрж░рзНржпржирзНржд ржЪрж▓рзЗ ржпрзЗрждрзЛред  
ржХрж┐ржирзНрждрзБ i->next != NULL ржжрж┐ржпрж╝рзЗ ржЖржорж░рж╛ i ржХрзЗ рж╢рзЗрж╖ ржирзЛржбрзЗрж░ ржЖржЧ ржкрж░рзНржпржирзНржд рж░рзЗржЦрзЗржЫрж┐,  
ржпрж╛рждрзЗ j ржПрж░ рж╕рж╛ржерзЗ рждрзБрж▓ржирж╛ ржХрж░рждрзЗ рж╕ржорж╕рзНржпрж╛ ржирж╛ рж╣ржпрж╝ред
*/

int main() {
    Node* head = NULL;
    Node* tail = NULL;

    int val;
    while (true) {
        cin >> val;
        if (val == -1) break;
        insert_at_tail(head, tail, val);
    }
    sort_linked_list(head);
    print_linked_list(head);

    return 0;
}
```

```cpp
Input:
5 9 2 4 1 -1

Output:
1
2
4
5
9

```


## Complexity of every operations on Singly Linked List
| Operation  |            | Complexity                      |
|------------|--------------------------|--------------------------------|
| Insertion  | at Head                  | O(1)                           |
|            | at Tail                  | O(N) -> without tail tracking  |
|            |                          | O(1) -> with tail tracking     |
|            | at any position          | O(N)                           |
| Deletion   | at Head                  | O(1)                           |
|            | at Tail                  | O(N)                           |
|            | at any position          | O(N)                           |
| Printing   | Forward                  | O(N)                           |
|            | Backward                 | O(N) -> using recursion        |
| Input      |                          | O(N) -> with tail tracking     |
|            |                          | O(N*N) -> without tail tracking|
| Sorting    |                          | O(N*N) -> using selection sort |




----





## Linked List Playground





<!-- <iframe src="https://linked-list-visualizer.vercel.app/app" width="100%" height="600" frameborder="0"></iframe> -->
<!-- <TheIframe src="https://linked-list-visualizer.vercel.app/app" /> -->
<script setup>
import { ref } from 'vue'

const isFullscreen = ref(false)

function toggleFullscreen() {
  isFullscreen.value = !isFullscreen.value
}

defineProps({
  src: String
})
</script>

<!-- <button class="maximize" @click="toggleFullscreen">
{{ isFullscreen ? 'Exit Fullscreen' : 'Fullscreen' }}
</button> -->

<div :class="['iframe-container', { fullscreen: isFullscreen }]">
    <button class="fullscreen-button" @click="toggleFullscreen">
      {{ isFullscreen ? 'Exit Fullscreen' : 'Fullscreen' }}
    </button>
    <iframe 
      src="https://linked-list-visualizer.vercel.app/app" 
      frameborder="0" 
      width="100%" 
      height="100%" 
      allowfullscreen>
    </iframe>
  </div>

<style>
.iframe-container {
  position: relative;
  width: 100%;
  height: 600px;
  transition: all 0.3s ease;
}

.fullscreen {
  position: fixed !important;
  top: 0; left: 0; right: 0; bottom: 0;
  width: 100vw !important;
  height: 100vh !important;
  z-index: 9999;
  background: white;
}
.maximize{
  z-index: 10000;
  display: block;
  background: #2b2b2b;
  color: white;
  border: none;
  padding: 6px 12px;
  cursor: pointer;
  border-radius: 4px;
  margin-bottom: 24px;
  margin-left: auto;
}
.fullscreen-button {
  position: absolute;
  top: 20px;
  right: 20px;
  z-index: 10000;
  background: #2b2b2b;
  color: white;
  border: none;
  padding: 6px 12px;
  cursor: pointer;
  border-radius: 4px;
}
</style>
